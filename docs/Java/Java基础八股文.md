> 该文档从各大平台搜集并学习后，根据自己的理解和需求而做的整合

## 基础概念

### Java语言的特点有哪些？
1. 面向对象：封装，继承，多态
2. 跨平台：Java虚拟机实现跨平台
3. 容易实现多线程：Java是一门高级语言，高级语言会对用户屏蔽很多底层的实现细节
4. 健壮性：Java的强类型机制、异常处理、垃圾的回收等都是健壮性的保证
5. 容易进行网络编程和分布式项目开发：Java语言诞生本身就是为了简化网络编程设计的，Java中有net api，它提供了网络应用编程的类库
6. 编译于解释并存：JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，机器码的运行效率高于Java解释器的

### Java与其他语言相比，有什么优点？
与C/C++相对比，Java语言是一种完全的面向对象语言，虽然它的底层（运行时库）是用C语言开发的，但不依赖于C。因为Java的运行是在运行时库的支持下进行的，所以运行效率比起可以更接近底层的C/C++来说会有所影响，不过Java的类库采用了很好的设计理念，比如：Java不提供指针来直接访问内存，程序内存更加安全、Java有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存、C ++同时支持方法重载和操作符重载，但是Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。Java一度成为了业界的一种标准开发语言，它的跨平台特性更是受到了很多开发者的青睐，只需要开发一次就能在所有安装了Java运行时库的环境运行。

与C#相比，C#是微软开发的一种编程语言，语法与Java类似，运行原理与Java也很类似，也是通过运行时库的支持运行。不过支持的平台有限，Java几乎被所有平台支持，而C#目前只被Windows和Linux支持，Windows下的支持是由微软自己开发的，而Linux下的支持则由mono支持。可实际上，mono也是把C#应用转化为Java应用，所以本质上C#仍只是被微软自己操作系统支持。应用平台的限制是它最大的缺点。

### JVM、JDK、JRE、JavaSE、JavaEE、JavaME、GC这些名词分别是什么意思？
JVM：Java Virtual Machine的缩写，Java虚拟机，是运行Java字节码的虚拟机，是跨平台的关键。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，他们都会有相同的结果。JVM并不是只有一种，只要满足JVM规范，每个公司、组织或者个人都可以开发自己的专属JVM。也就是说平时接触到的HotSpot VM仅仅只是JVM规范的一种实现。Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行字节码，就可以在多种平台上不加修改就运行。

JDK：Java Development Kit的缩写，Java开发工具包，是功能齐全的Java SDK。JDK是整个Java的核心，包括了Java运行环境（JRE）所拥有的一切，还有编译器（javac）和工具（javadoc和jdb），它能够用来创建和编译程序。

JRE：Java Runtime Environment的缩写，它是运行已经编译Java程序所需的所有内容的集合，包含JVM标准实现和JAVA核心类库，它能用来编译程序，不能用于创建新程序。所以如果只是运行Java程序的话，那么只需要安装JRE就可以了。如果是要进行一些Java编程，就需要安装JDK。但，这并不绝对。例如：如果要使用JSP部署Web程序，从技术上讲只需要应用程序程序服务器（Tomcat等）中运行Java程序，但是因为应用程序服务器会将JSP转换为Java Servlet，而Servlet需要JDK来编译，此时便是需要下载JDK的。

JavaSE：Java Standard Edition的缩写，标准版，一开始叫J2SE，是常用的一个版本，从JDK5.0开始改名为Java SE，主要应用于桌面应用软件的编程，是Java EE和Java ME的基础。

JavaEE：Java Enterprise Edition的缩写，企业版，JavaEE是J2EE的一个新的名称，是企业开发使用的一个版本，主要用于分布式的网络程序的开发。

JavaME：Java Micro Edition的缩写，微型版，一般用于移动设备和嵌入式设备，如：机顶盒、移动电话和PDA等，为它们所提供Java语言平台，包括虚拟机和一系列标准化的Java API。

GC：Garbage Collection的缩写，垃圾回收，当Java虚拟机发觉内存资源紧张时，则会自动地去清理无用对象（没有被引用的对象）所占用的内存空间。

### 什么是字节码？采用字节码的好处是什么？

字节码是程序的一种低级表示，Java源代码经过编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合Java虚拟机的规范，那么Java虚拟机就能够执行该字节码文件。

字节码文件中，一般包含以下部分：
- 版本号信息
- 静态常量池（符号常量）
- 类相关的信息
- 字段相关的信息
- 方法相关的信息
- 调试相关的信息

可以说，大部分信息都是通过常量池中的符号常量来表述的

采用字节码的好处是，Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以，Java程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

### JVM能有几个实例，以及怎么利用JVM实现跨平台的？
每个Java程序对应一个JVM实例，当一个Java程序运行时就会创建一个JVM实例，因此JVM实例的个数取决于同时执行的程序个数。

Java跨平台因为有JVM屏蔽了底层操作系统，Java源代码（*.java）经过Java编译器编译成Java字节码（*.class），执行Java字节码，Java字节码经过JVM解释为具体平台的具体指令并执行。不同平台有不同的JVM，主流平台都提供了JVM，所以Java字节码可以在主流平台上能够解释执行。在这个意义上Java是跨平台的，也就是说：Java的字节码是跨平台的。

### 从JVM的角度，总结一下Java源码到执行的过程？

这个过程可以总结为四个步骤：编译->加载->解释->执行

- 编译：经过 语法分析、语义分析、注解处理 最后才生成会class文件
- 加载：可以细分步骤为：装载->连接->初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析
- 解释：则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度
- 执行：调用系统的硬件执行最终的程序指令

### 简单描述一下Java源码到执行的过程？
  
Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令,.class文件)---->jvm---->jvm中 解释器----->机器可执行的二进制机器码---->程序运行。

### 简单描述一下JIT编译器？

当`.class->机器码`，这个过程中JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后来引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。

### 为什么说Java语言是“编译与解析并存”？

首先需要了解`编译型`和`解析型`语言分别是什么

- 编译型 ：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。

- 解释型 ：解释型语言会通过解释器一句一句的将代码解释为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。
所以Java 语言既具有编译型语言的特征，也具有解释型语言的特征。


## 基本语法

### Java有哪些数据类型？
定义：

Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。

分类：

基本数据类型
- 数值型
  - 整数类型(byte,short,int,long)
  - 浮点类型(float,double)
- 字符型(char)
- 布尔型(boolean)

引用数据类型
- 类(class)
- 接口(interface)
- 数组([])

基本数据类型图

![](https://resource.lzyan.fun/PigGo/20211201223216.png)

### Java有哪些运算符？

运算符不只 Java 中有，其他语言也有运算符，运算符是一些特殊的符号，主要用于数学函数、一d些类型的赋值语句和逻辑比较方面。以Java为例，有以下运算符

- 赋值运算符：例如int a = 10，把 = 号右边的值复制给左边，右边的值可以是任何常数、变量或者表达式，但左边的值必须是一个明确的，已经定义的变量
- 算数运算符：+ 加、- 减、* 乘、/ 除、% 取余
- 自增自减运算符：++、--，要注意放在前还是后
- 比较运算符：> 大于、< 小于、== 等于、>= 大于等于、<= 小于等于、!= 不等于
- 逻辑运算符：&& 短路与、|| 短路或、! 逻辑非、& 逻辑与、| 逻辑或、^ 逻辑异或，其中短路与判断到false就停止往下的判断，短路或直到判断到结果为true
- 按位运算符：& 按位与、| 按位或、~ 按位非、^ 按位异或
- 移位运算符：>> 右移、<< 左移
- 三元运算符：条件表达式?表达式1:表达式2

### Java有哪些常见的关键字？

![](https://resource.lzyan.fun/PigGo/20211202094253.png)

### 什么是包装类？为什么需要包装类？

Java中的8个基本数据类型，分别对应了8个包装类

- 基本数据类型方便、简单、高效、但泛型不支持、集合元素不支持
- 不符合面向对象思维
- 包装类提供很多方法，方便使用如Integer类toHexString(int i)、parsenInt(String s)方法等

### Java基本类型的包装类常量池技术是什么？

Java基本类型的包装类大部分都实现了常量池技术，常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。

Byte,Short,Integer,Long,Character,Boolean；

前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。至于为什么是在-128~127之间，可查阅源码Integer类中有一个静态内部类IntegerCache，在IntegerCache类中有一个Integer数组，用以缓存当前数值范围-128~127时的Integer对象。其中两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。

```java
Integer i1 = 66;
Integer i2 = 66;
System.out.println(i1 == i2);//true 在范围内比较的是直接缓存的数据

Integer i3 = 128;
Integer i4 = 128;
System.out.println(i3 == i4);//false 在-128~127范围外，比较的是对象

Float f1 = 222f;
Float f2 = 222f;
System.out.println(f1 == f2);//false

Double d1 = 2.2;
Double d2 = 2.2;
System.out.println(d1 == d2);//false
```
需要注意一点：这是阿里Java开发手册中的一条规定
![](https://resource.lzyan.fun/PigGo/20211206223304.png)

### 什么是自动装箱拆箱？

例如：
```java
Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
```
简单来说：装箱就是自动将基本数据类型转换为包装类类型，拆箱就是自动将包装器类型转换为基本数据类型。

装箱拆箱这个过程是自动执行的，所以我们需要通过反编译上面代码编译后的class文件得到对应的字节码来看它的执行过程：

![](https://resource.lzyan.fun/PigGo/2021-12-06_230145.png)

从字节码中可以发现，装箱其实就是调用了包装类的ValueOf()方法，拆箱就是调用了intValue()方法。

因此:
- Integer i = 10 等价于 Integer i = Integer.valueOf(10)
- int n = i 等价于 int n = i.intValue();

注意:装箱和拆箱过程需要进行大量的计算，装箱和拆箱操作会从速度和内存两个方面损伤应用程序的性能，因此应该清楚编译器会在何时自动产生执行这些操作的指令并尽量避免不必要的装拆箱操作，

### new Integer(123) 与 Integer.valueOf(123) 的区别？

- new Integer(123) 每次都会新建一个对象；
- Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```

### String类是用什么数据结构来存储字符串的？String类可以被继承吗？

String类是用数组的数据结构来存储字符串的，String类是被final修饰符修饰的，而被final修饰的类是不能被继承的

### String为什么是不可变的？

- 保存字符串的数组被final修饰且私有的，并且String类没有提供/暴露修改这个字符串的方法
- String类被final修饰导致其不能被继承，进而避免了子类破坏String不可变
- String不可变的关键在于底层的实现，而不是一个final

### String不可变的好处？

1. 可以缓存hash值

因为String的hash值经常被使用，例如String用作HashMap的key，不可变的特性可以使得hash值也不可变，因此只需要进行一次计算

1. String pool的需要

如果一个String对象已经被创建过了，那么就会从String pool中取得引用。只有String是不可变的，才可能使用String pool

3. 安全性

String经常作为参数，String的不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果String是可变的，那么在网络连接的过程中String被改变，改变的一方以为现在连接的是其他的主机而实际情况却不一定是

4. 线程安全

String中的对象是不可变的，也就可以理解为常量，线程安全

### String、StringBuffer和StringBuilder的区别，以及它们的使用场景？

1. 可变性

String不可变

StringBuffer和StringBuilder可变

2. 线程安全

String不可变，因此是线程安全的

StringBuilder不是线程安全的

StringBuffer是线程安全，内部使用synchronized进行同步

3. 性能

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，StringBuffer和StringBuilder类的对象能够被多次修改，并且不产生新的未使用的对象

使用场景：

- 如果操作少量的数据用String
- 多线程操作字符串时缓冲区下操作大量数据，使用StringBuffer
- 单线程操作字符串时缓冲区下操作大量数据，使用StringBuilder（相比较于StringBuffer有速度优势）

### Object类是什么？

Object 类是一个特殊的类，是所有类的父类。java中如果一个类没有用 extends关键字 明确指出继承于某个类，那么它默认继承Object类。

Object 类的通用方法：
```java
public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
```

### ==和equals()的区别是什么？

== 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，==比较的是值
- 对于引用数据类型来说，==比较的是对象的内存地址

equals() 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。它存在于Object类中，
equals() 方法存在两种使用情况：

- 没有覆盖equals()方法：通过equals()比较该类的对象时，等价于通过“==”比较这两个对象，使用的默认是Object类equals()方法
- 类覆盖了equals()方法：一般我们都覆盖equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回true（即认为这两个对象相等）

关于String类中的equals()方法：

- String类中的equals()方法是被重写过的，因为Object的equals()方法比较的是对象的内存地址，而String的equals()方法比较的是对象的值
- 当创建String类型对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象

```java
String a = new String("ab"); //a为一个引用
String b = new String("ab"); //b为另一个引用，对象内容一样
String aa = "ab"; //放在常量池
String bb = "ab"; //从常量池中查找
System.out.println(aa==bb); //true
System.out.println(a==b); //false
System.out.println(a.equals(b)); //true 
System.out.println(42 == 42.0);// true
```

### hashCode()方法的作用？

作用：

hashCode()方法的作用是获取哈希码，也称散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。

hashCode()方法定义在JDK的Object类中，这就意味着Java中的任何类都包含hashCode()函数。另外需要注意的是：Object的hashCode()方法是本地方法，也就是用C语言或C++实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

虽然，每个Java类都包含hashCode()函数，但是仅仅当创建某个“类的散列表”时，该类的hashCode()才有用（作用是：确定该类的每一个对象在散列表中的位置），其他情况下，例如创建类的单个对象或者创建类的对象数组，类的hashCode()没有作用

上面的散列表指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。

上面提到的散列码的作用：

- 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！
- 散列表的本质是通过数组实现的。当我们要获取散列表中的某个“值”时，实际上是要获取数组中的某个位置的元素。而数组的位置，就是通过“键”来获取的；更进一步说，数组的位置，是通过“键”对应的散列码计算得到的。

以HashSet为例，深入理解hashCode()的作用：

  假设，HashSet中已经有1000个元素。当插入第1001个元素时，需要怎么处理？因为HashSet是Set集合，它允许有重复元素。

  将第1001个元素逐个的和前面1000个元素进行比较？显然，这个效率是相等低下的。散列表很好的解决了这个问题，它根据元素的散列码计算出元素在散列表中的位置，然后将元素插入该位置即可。对于相同的元素，自然是只保存了一个。

  由此可知，若两个元素相等，它们的散列码一定相等；但反过来却不一定。

  也就是说，在散列表中：1.如果两个对象相等，那么它们的hashCode()值一定要相同；2.如果两个对象hashCode()相等，它们并不一定相等。这是在散列表中的情况，在非散列表中比一定如此

### hashCode()和equals()的关系?

重写equals()方法时一般需要重写hashCode()方法，这两个方法是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，equals()方法默认比较是采用hashCode()值比较

当重写equals()方法时，说明我们想要更改判断对象是否相等的方式，因此我们需要同时重写hashCode()，才能保证对象判断方式是我们想要的效果

如果在重写equals()方法时，不重写hashCode()方法，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行

### 关于Object类中的toString()方法？

Object类的toString()方法默认返回该对象实现类的“类名+@+hashcode”值，而这个返回值不能实现自我描述功能，所以可以重写toString()方法来实现描述。至于要不要进行重写需要根据需要来定

### 深拷贝、浅拷贝是什么？

- 浅拷贝并不是真的拷贝，只是 **复制指向某个对象的指针** ，而不复制对象本身，新旧对象还是共享同一块内存。
- 深拷贝会另外 **创造一个一模一样的对象** ，新对象跟原对象不共享内存，修改新对象不会改到原对象。

### switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？

在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的，如果值过于复杂，那么还是用 if 比较合适

### continue、break 和 return 的区别是什么？

在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词： 
 - continue ：指跳出当前的这一次循环，继续下一次循环
 - break ：指跳出整个循环体，继续执行循环下面的语句
return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：
 - return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法 
 - return value; ：return 一个特定值，用于有返回值函数的方法 

### 静态方法为什么不能调用非静态成员？

这个需要结合JVM的相关知识，主要原因如下：

1. 静态方法属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才会存在，需要通过类的实例对象去访问
2. 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作 

### 实例变量和静态变量是什么？他们有什么区别？

实例变量和静态变量都属于成员变量

实例变量：定义在类中但在任何方法之外，当一个对象被实例化之后，每个实例变量的值就跟着确定，它与该实例同生共死

静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名进行访问。静态变量在内存中只存在一份，在类加载的时候分配

区别：
1. 存放位置：静态变量随着类的加载存在于方法区中，实例变量随着对象的建立存在于堆内存
2. 生命周期：静态变量的生命周期最长随着类的加载而加载消失而消失，实例变量与实例同生共死

### static关键字的使用方式有哪些？

1. 静态变量：static修饰的变量
2. 静态方法：静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，不能是抽象方法。方法中不能有this和super关键字，因为这两个关键字与具体对象关联
3. 静态语句块：在类初始化的时候运行一次
4. 静态内部类：非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类，而静态内部类是不需要的。静态内部类不能访问外部类的非静态的变量和方法
5. 静态导包：使用import static用来导入某个类或者包中的静态方法或者静态变量

### final的作用？

1. 修饰类

声明类不可以被继承

2. 修饰方法

声明方法不能被子类重写

用private修饰的方法隐式地被指定final，如果子类中定义的方法和父类中一个用private修饰的方法的方法名相同，此时子类的方法不是重写父类的方法，而是在子类中重新定义了一个方法

3. 修饰数据

声明数据为常量，可以是编译时常量，也可以是运行时被初始化后不能被改变的常量

```java
public class TestFinal{
  final int f1 = 1; // 编译时常量
  final int f2 ; // 运行时初始化常量
  public TestFinal(){
      this.f2 = 1;
  }
}
```
- 对于基本类型，final使数值不变

- 对于引用类型，final使引用不变，也就不能引用其他对象，但是被引用的对象本身是可以修改的
```java
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1; // 修改被引用对象本身的属性
```
注意：final修饰的方法参数也同样时遵循以上两点


### Java中类的初始化顺序？

一个类中包含如下的东西：
1. 静态变量：staic开头定义的属性
2. 静态语句块：static{}圈起来的方法块
3. 实例变量：未带有static定义的属性
4. 普通语句块：{}圈起来的方法块
5. 构造函数：跟类名相同的方法
6. 方法：普通的方法

普通类的情况下，初始化顺序为：
- 静态变量
- 静态语句块
- 实例变量
- 普通语句块
- 构造函数

存在继承的情况下，初始化顺序为：
- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）

包含接口、抽象类情况下（普通类继承抽象类并实现接口），初始化顺序为：
- 接口静态变量
- 抽象类静态变量
- 抽象类静态语句块
- 实现类（普通类）静态属性
- 实现类静态语句块
- 抽象类实例变量
- 抽象类普通语句块
- 抽象类构造方法
- 实现类实例变量
- 实现类普通语句块
- 实现类构造函数


## 面向对象

### 面向对象和面向过程的区别？

- 面向过程：

  面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数

    优点：面向过程性能比面向对象高，因为面向对象类调用时需要实例化，开销比较大，比较消耗资源;当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发

    缺点：面向过程没有面向对象易维护、易复用、易扩展

- 面向对象：

  面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为

    优点：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护

    缺点：面向对象性能比面向过程低

### 面向对象的特征有哪些？

- 抽象：

抽象是将一类对象的共同特征总结出来从而构造类的过程，包括数据抽象和行为抽象两方面，抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

- 封装：

封装是把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没 有提供给外界访问的方法，那么这个类也没有什么意义了。面向对象设计始于这个基本概念。

- 继承：

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

关于继承如下 3 点请记住：
1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法，即重写父类方法。

- 多态：

所谓多态就是指程序中父类或接口定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象的精髓。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。

多态的特点：
1. 方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）；
2. 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
3. 多态不能调用“只在子类存在但在父类不存在”的方法；
4. 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法；

记住：其中封装、继承、多态是面向对象编程的三大特征

### 面向对象的五大基本原则是什么？

- 单一职责原则SRP(Single Responsibility Principle)

是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

- 开放封闭原则OCP(Open－Close Principle) 

一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

- 里式替换原则LSP(the Liskov Substitution Principle LSP)

子类应当可以替换父类并出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活~

- 依赖倒置原则DIP(the Dependency Inversion Principle DIP)

高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。我们知道，依赖一定会存在于类与类、 模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 

- 接口分离原则(the Interface Segregation Principle ISP)

接口端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。如果一个提供接口的类中对于它的子类来说不是最小的接口，那么它的子类在实现该类的时候就必须实现一些自己不需要的功能，整个系统就会慢慢变得臃肿难以维护。

[详解](https://zhuanlan.zhihu.com/p/63215764)

### 抽象类和接口的区别？

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

相同点：

1. 接口和抽象类都不能实例化
2. 都位于继承的顶端，用于被其他实现或继承
3. 都包含抽象方法，其子类都必须覆写这些抽象方法

不同点：

|    参数    |                            抽象类                            |                             接口                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    声明    |                 抽象类使用abstract关键字声明                 |                 接口使用interface关键字声明                  |
|    实现    | 子类使用extends关键字来继承抽象类。如果子类 不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用implements关键字来实现 接口。它需要提供接口中所有声明的 方法的实现 |
|   构造器   |                      抽象类可以有构造器                      |                       接口不能有构造器                       |
| 访问修饰符 |              抽象类中的方法可以是任意访问修饰符              | 接口方法默认修饰符是public。并且 不允许定义为 private 或者 protected , 从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。|
|   多继承   |                 一个类最多只能继承一个抽象类                 |                    一个类可以实现多个接口                    |
|  字段声明  |                 抽象类的字段声明可以是任意的                 |            接口的字段默认都是 static 和 final 的             |

备注：在JDK1.8以前，接口(interface)没有提供任何具体的实现，在《JAVA编程思想》中是这样描述的：“interface这个关键字产生了一个完全抽象的类，它根本就没有提供任何具体的实现。它允许创建者确定方法名、参数列表和返回类型，但是没有任何方法体。接口只提供了形式，而未提供任何具体实现”。但是这一限制在JDK1.8中被打破了，JDK1.8开始，接口允许定义默认方法和静态方法，这是因为不支持默认方法的接口的维护成本太高了。在 JDK1.8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。
```java
默认方法：
default 返回值类型 方法名(参数列表) { // 实现体 }
实现类中可以选择性重写接口的默认方法
静态方法：
静态方法的使用比较简单，和类中的静态方法没有什么区别
static 返回值类型 方法名(参数列表) { // 实现体 }

注意：static和default关键字不能同时使用，即一个接口方法不可能既是静态的又是默认方法。
```
所以，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。接口和抽象类各有优缺点，在接口和抽象类的使用选择上，必须遵守这样一个原则：

1. 行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。并且从 JDK1.8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。

2. 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。

### 普通类和抽象类的区别？

普通类不能包含抽象方法，抽象类可以包含抽象方法。

普通类可以直接实例化，抽象类不能直接实例化。

普通类使用final修饰后不可被继承，抽象类不能用final修饰。

### 创建一个对象用什么运算符?对象实例与对象引用有何不同?

创建一个对象用 new 运算符

- 对象实例：如new Person()，new 创建对象实例（对象实例在堆内存）。
- 对象引用：如Person p = new Person()，= 左边的对象引用指向右边的对象实例（对象引用存放在栈内存中）。

一个对象引用可以指向0个或1个对象，一个对象可以有n个引用指向它。

### 对象的相等与指向他们的引用相等,两者有什么不同？

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

### super和this的区别？使用时需要注意什么？

this：

代表对象本身，可以理解为指向对象本身的一个指针。使用方式：
1. 普通的直接引用
2. 方法形参与成员名字重名，用this来区分
3. 引用构造函数：调用本类中另一种形式的构造函数

spuer：

super可以理解为是指向自己父类对象的一个指针，而这个父类指的是离自己最近的一个父类。使用方式：
1. 普通的直接引用
2. 子类中的成员变量或方法与父类中的成员变量或方法同名
3. 引用构造函数：子类调用父类中的某一个构造函数

注意：

1. 调用super()必须写在子类构造方法的第一行，否则编译不通过。子类一定会调用父类的构造函数来完成初始化工作，每个子类构造方法的第一条语句，都是隐含地调用super()，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。
2. super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。
3. super() 和 this() 均需放在构造方法内第一行。
4. 尽管可以用this调用一个构造器，但却不能调用两个。
5. this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
6. this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
7. 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。


### 重载和重写什么区别？

重载：
 - 必须具有不同的参数列表
 - 可以有不同的返回类型，只要参数列表不同就可以了
 - 可以有不同的访问修饰符
 - 可以抛出不同的异常

重写：
 - 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载
 - 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载
 - 访问修饰符的限制一定要大于被重写方法的访问修饰符
 - 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

总结：

| **区别点** | **重载方法** |                         **重写方法**                         |
| :--------: | :------: | :----------------------------------------------------------: |
|  发生范围  | 同一个类 |                             子类                             |
|  参数列表  | 必须修改 |                         一定不能修改                         |
|  返回类型  |  可修改  |      子类方法返回值类型应比父类方法返回值类型更小或相等      |
|    异常    |  可修改  | 子类方法声明抛出的异常类应比父类方法声明抛出的异常更小或相等 |
| 访问修饰符 |  可修改  |            一定不能做更严格的限制（可以降低限制）            |
|  发生阶段  |  编译器  |                            运行期                            |

综上：`重载`就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理，`重写`就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变

注意：关于重写的返回值类型,如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的

### 成员变量与局部变量的区别？

变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域 

成员变量：方法外部，类内部定义的变量。

局部变量：类的方法中的变量。 

成员变量和局部变量的区别：

- 作用域

成员变量：针对整个类有效。

局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)

- 存储位置

成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。

局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。

- 生命周期

成员变量：随着对象的创建而存在，随着对象的消失而消失。

局部变量：当方法调用完，或者语句结束后，就自动释放。

- 初始值

成员变量：有默认初始值。

局部变量：没有默认初始值，使用前必须赋值。

- 使用原则

在使用变量时需要遵循的原则为：就近原则首先在局部范围找，有就使用；接着在成员位置找。