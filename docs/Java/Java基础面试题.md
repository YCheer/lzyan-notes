> 该文档从各大平台搜集并学习后，根据自己的理解和需求而做的整合

## 概述

### Java语言的特点有哪些？
1. 面向对象：封装，继承，多态
2. 跨平台：Java虚拟机实现跨平台
3. 容易实现多线程：Java是一门高级语言，高级语言会对用户屏蔽很多底层的实现细节
4. 健壮性：Java的强类型机制、异常处理、垃圾的回收等都是健壮性的保证
5. 容易进行网络编程和分布式项目开发：Java语言诞生本身就是为了简化网络编程设计的，Java中有net api，它提供了网络应用编程的类库
6. 编译于解释并存：JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，机器码的运行效率高于Java解释器的

### Java与其他语言相比，有什么优点？
与C/C++相对比，Java语言是一种完全的面向对象语言，虽然它的底层（运行时库）是用C语言开发的，但不依赖于C。因为Java的运行是在运行时库的支持下进行的，所以运行效率比起可以更接近底层的C/C++来说会有所影响，不过Java的类库采用了很好的设计理念，比如：Java不提供指针来直接访问内存，程序内存更加安全、Java有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存、C ++同时支持方法重载和操作符重载，但是Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。Java一度成为了业界的一种标准开发语言，它的跨平台特性更是受到了很多开发者的青睐，只需要开发一次就能在所有安装了Java运行时库的环境运行。

与C#相比，C#是微软开发的一种编程语言，语法与Java类似，运行原理与Java也很类似，也是通过运行时库的支持运行。不过支持的平台有限，Java几乎被所有平台支持，而C#目前只被Windows和Linux支持，Windows下的支持是由微软自己开发的，而Linux下的支持则由mono支持。可实际上，mono也是把C#应用转化为Java应用，所以本质上C#仍只是被微软自己操作系统支持。应用平台的限制是它最大的缺点。

### JVM、JDK、JRE、JavaSE、JavaEE、JavaME、GC这些名词分别是什么意思？
JVM：Java Virtual Machine的缩写，Java虚拟机，是运行Java字节码的虚拟机，是跨平台的关键。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，他们都会有相同的结果。JVM并不是只有一种，只要满足JVM规范，每个公司、组织或者个人都可以开发自己的专属JVM。也就是说平时接触到的HotSpot VM仅仅只是JVM规范的一种实现。Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行字节码，就可以在多种平台上不加修改就运行。

JDK：Java Development Kit的缩写，Java开发工具包，是功能齐全的Java SDK。JDK是整个Java的核心，包括了Java运行环境（JRE）所拥有的一切，还有编译器（javac）和工具（javadoc和jdb），它能够用来创建和编译程序。

JRE：Java Runtime Environment的缩写，它是运行已经编译Java程序所需的所有内容的集合，包含JVM标准实现和JAVA核心类库，它能用来编译程序，不能用于创建新程序。所以如果只是运行Java程序的话，那么只需要安装JRE就可以了。如果是要进行一些Java编程，就需要安装JDK。但，这并不绝对。例如：如果要使用JSP部署Web程序，从技术上讲只需要应用程序程序服务器（Tomcat等）中运行Java程序，但是因为应用程序服务器会将JSP转换为Java Servlet，而Servlet需要JDK来编译，此时便是需要下载JDK的。

JavaSE：Java Standard Edition的缩写，标准版，一开始叫J2SE，是常用的一个版本，从JDK5.0开始改名为Java SE，主要应用于桌面应用软件的编程，是Java EE和Java ME的基础。

JavaEE：Java Enterprise Edition的缩写，企业版，JavaEE是J2EE的一个新的名称，是企业开发使用的一个版本，主要用于分布式的网络程序的开发。

JavaME：Java Micro Edition的缩写，微型版，一般用于移动设备和嵌入式设备，如：机顶盒、移动电话和PDA等，为它们所提供Java语言平台，包括虚拟机和一系列标准化的Java API。

GC：Garbage Collection的缩写，垃圾回收，当Java虚拟机发觉内存资源紧张时，则会自动地去清理无用对象（没有被引用的对象）所占用的内存空间。

### 什么是字节码？采用字节码的好处是什么？

字节码是程序的一种低级表示，Java源代码经过编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合Java虚拟机的规范，那么Java虚拟机就能够执行该字节码文件。

字节码文件中，一般包含以下部分：
- 版本号信息
- 静态常量池（符号常量）
- 类相关的信息
- 字段相关的信息
- 方法相关的信息
- 调试相关的信息

可以说，大部分信息都是通过常量池中的符号常量来表述的

采用字节码的好处是，Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以，Java程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

### JVM能有几个实例，以及怎么利用JVM实现跨平台的？
每个Java程序对应一个JVM实例，当一个Java程序运行时就会创建一个JVM实例，因此JVM实例的个数取决于同时执行的程序个数。

Java跨平台因为有JVM屏蔽了底层操作系统，Java源代码（*.java）经过Java编译器编译成Java字节码（*.class），执行Java字节码，Java字节码经过JVM解释为具体平台的具体指令并执行。不同平台有不同的JVM，主流平台都提供了JVM，所以Java字节码可以在主流平台上能够解释执行。在这个意义上Java是跨平台的，也就是说：Java的字节码是跨平台的。

### 从JVM的角度，总结一下Java源码到执行的过程？

这个过程可以总结为四个步骤：编译->加载->解释->执行

- 编译：经过 语法分析、语义分析、注解处理 最后才生成会class文件
- 加载：可以细分步骤为：装载->连接->初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析
- 解释：则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度
- 执行：调用系统的硬件执行最终的程序指令

### 简单描述一下Java源码到执行的过程？
  
Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令,.class文件)---->jvm---->jvm中 解释器----->机器可执行的二进制机器码---->程序运行。

### 简单描述一下JIT编译器？

当`.class->机器码`，这个过程中JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后来引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。

### 为什么说Java语言是“编译与解析并存”？

首先需要了解`编译型`和`解析型`语言分别是什么

- 编译型 ：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。

- 解释型 ：解释型语言会通过解释器一句一句的将代码解释为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。
所以Java 语言既具有编译型语言的特征，也具有解释型语言的特征。


## 基础

### Java有哪些数据类型？
定义：

Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。

分类：

基本数据类型
- 数值型
  - 整数类型(byte,short,int,long)
  - 浮点类型(float,double)
- 字符型(char)
- 布尔型(boolean)

引用数据类型
- 类(class)
- 接口(interface)
- 数组([])

基本数据类型图
![](https://resource.lzyan.fun/PigGo/20211201223216.png)

### Java有哪些运算符？

运算符不只 Java 中有，其他语言也有运算符，运算符是一些特殊的符号，主要用于数学函数、一d些类型的赋值语句和逻辑比较方面。以Java为例，有以下运算符

- 赋值运算符：例如int a = 10，把 = 号右边的值复制给左边，右边的值可以是任何常数、变量或者表达式，但左边的值必须是一个明确的，已经定义的变量
- 算数运算符：+ 加、- 减、* 乘、/ 除、% 取余
- 自增自减运算符：++、--，要注意放在前还是后
- 比较运算符：> 大于、< 小于、== 等于、>= 大于等于、<= 小于等于、!= 不等于
- 逻辑运算符：&& 短路与、|| 短路或、! 逻辑非、& 逻辑与、| 逻辑或、^ 逻辑异或，其中短路与判断到false就停止往下的判断，短路或直到判断到结果为true
- 按位运算符：& 按位与、| 按位或、~ 按位非、^ 按位异或
- 移位运算符：>> 右移、<< 左移
- 三元运算符：条件表达式?表达式1:表达式2

### Java有哪些常见的关键字？

![](https://resource.lzyan.fun/PigGo/20211202094253.png)

### switch是否能作用在byte上，是否能作用在long上，是否能作用在String上？

在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入
了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整
型（long）在目前所有的版 本中都是不可以的

### continue、break 和 return 的区别是什么？

在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词： 
 - continue ：指跳出当前的这一次循环，继续下一次循环
 - break ：指跳出整个循环体，继续执行循环下面的语句
return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：
 - return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法 
 - return value; ：return 一个特定值，用于有返回值函数的方法 

### 重载和重写什么区别？

重载：
 - 必须具有不同的参数列表
 - 可以有不同的返回类型，只要参数列表不同就可以了
 - 可以有不同的访问修饰符
 - 可以抛出不同的异常

重写：
 - 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载
 - 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载
 - 访问修饰符的限制一定要大于被重写方法的访问修饰符
 - 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

总结：

| **区别点** | **重载方法** |                         **重写方法**                         |
| :--------: | :------: | :----------------------------------------------------------: |
|  发生范围  | 同一个类 |                             子类                             |
|  参数列表  | 必须修改 |                         一定不能修改                         |
|  返回类型  |  可修改  |      子类方法返回值类型应比父类方法返回值类型更小或相等      |
|    异常    |  可修改  | 子类方法声明抛出的异常类应比父类方法声明抛出的异常更小或相等 |
| 访问修饰符 |  可修改  |            一定不能做更严格的限制（可以降低限制）            |
|  发生阶段  |  编译器  |                            运行期                            |

综上：`重载`就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理，`重写`就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变

注意：关于重写的返回值类型,如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的