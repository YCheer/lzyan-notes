> 八股文整合，该系列文档搜集于各大平台，据理解和需求整合
> 
> 参考资料平台：javaGuide、java3y、cs-notes、廖雪峰的Java教程、javacore，另外有的除了这些还会在内容中有标注

## IO 模型

### 什么是IO？

`IO` 是输入 `input` 输出 `output` 的首字母缩写形式，直观意思是计算机输入输出，它描述的是计算机的数据流动的过程，因此 `IO` 第一大特征是有 `数据的流动` ；另外，对于一次`IO`，它究竟是输入还是输出，是针对不同的主体而言的，不同的主体有不同的描述。例如，甲乙两人交谈，甲将大脑中的想法通过声带震动，继而通过声波传入乙的耳朵，乙通过耳膜的震动再由神经将信号解析到大脑，这个数据流动的过程对甲而言是输出，对乙而言是输入。因此，理解 `IO` 一定要弄清楚所要研究的本体，下面从三个层面来理解。

- **首先，从直观层面去理解 IO**

此时，`IO` 是计算机和外设之间的数据流动过程，本体是一个有使用意义的可运行的电脑，它是计算机运行的完全必要部分。姑且认为这个完全必要部分是台式电脑的主机，里面有CPU、内存、主板、电源等设备，因为有了这些，一台有使用意义的电脑即可运行。有了主机，并不能方便的为人所服务，因此得有外设。外设是电脑的外围设备，如显示器、键盘、鼠标等，它们是完成人机交互的辅助工具。外设包含两种重要设备（但不限于此）：输入设备和输出设备。像鼠标键盘属于输入设备，将人的指令转成“鼠键行为”这种数据传给主机；显示器是输出设备，主机通过运算，把“返回信息”这种数据传给显示器。

- **其次，从计算机架构的角度去理解 IO**

从计算机架构上来讲，任何涉及到计算机核心（CPU和内存）与其他设备间的数据转移的过程就是 `IO`。本体就是计算机核心（CPU和内存）。例如从硬盘上读取数据到内存，是一次输入，将内存中的数据写入到硬盘就产生了输出。在计算机的世界里，这就是 `IO` 的本质。

- **最后，从编程的角度去理解 IO**

此时，`IO` 的主体是其应用程序的运行态，即 `进程`，特别强调的是我们的应用程序其实并不存在实质的 `IO` 过程，真正的 `IO` 过程是操作系统的事情，这里把应用程序的 `IO` 操作分为两种动作：`IO调用`和 `IO执行`。**IO调用是由进程发起，IO执行是操作系统的工作**。因此，更准确些来说，此时所说的 **IO是应用程序对操作系统IO功能的一次触发，即IO调用**。

`IO调用` 的目的是将进程的内部数据迁移到外部即输出，或将外部数据迁移到进程内部即输入。这里，外部数据指非进程空间数据，在编程时，通常讨论的场景是来自外部存储设备的数据，如硬盘、CD-ROM、以及需要socket通信传输的网络数据。

以一个进程的输入类型的 `IO调用` 为例，它将完成或引起如下工作内容：

1. 进程向操作系统请求外部数据。
2. 操作系统将外部数据加载到内核缓冲区。
3. 操作系统将数据从内核缓冲区拷贝到进程缓冲区。
4. 进程读取数据继续后面的工作。

总结：从上面的描述来看，我们更容易理解一个 `IO` 操作，应用程序和操作系统都干了些什么，也帮助我们更容易理解阻塞和非阻塞，异步和同步的相关 `IO` 编程概念。

### 什么是阻塞和非阻塞 IO？

阻塞和非阻塞强调的是进程对于操作系统 `IO` 是否处于 `就绪状态` 的处理方式。

应用程序的 `IO` 实际是分为两个步骤，`IO调用` 和 `IO执行`。`IO调用` 是由进程发起，`IO执行` 是操作系统的工作。操作系统的 `IO` 情况决定了进程 `IO调用` 是否能够得到立即响应。如进程发起了读取数据的 `IO调用` ，操作系统需要将外部数据拷贝到 `进程缓冲区` ，在有数据拷贝到 `进程缓冲区` 前，`进程缓冲区` 处于不可读状态，我们称之为操作系统 `IO未就绪`。

进程的 `IO调用` 是否能得到立即执行是需要操作系统` IO` 处于 `就绪状态` 的，对于读取数据的操作，如果操作系统 `IO` 处于 `未就绪状态`，当前进程或线程如果一直等待直到其就绪，该种 `IO` 方式为 `阻塞IO`。如果进程或线程并不一直等待其就绪，而是可以做其他事情，这种方式为 `非阻塞IO` 。所以对于 `非阻塞IO`，我们编程时需要经常去轮询 `就绪状态` 。

### 什么是异步和同步 IO？

同步和异步描述的是针对当前执行线程、或进程而言，发起 `IO调用` 后，当前线程或进程是否挂起等待操作系统的 `IO` 执行完成。

当一个 `IO` 执行是同步执行的，意思是程序发起 `IO调用`，当前线程或进程需要等待操作系统完成 `IO` 工作并告知进程已经完成，线程或进程才能继续往下执行其他既定指令。如果说一个 `IO` 执行是异步的，意思是该动作是由当前线程或进程请求发起，且当前线程或进程不必等待操作系统 `IO` 的执行完毕，可直接继续往下执行其他既定指令。操作系统完成 `IO` 后，当前线程或进程会得到操作系统的通知。

以一个读取数据的 `IO` 操作而言，在操作系统将外部数据写入进程缓冲区这个期间，进程或线程挂起等待操作系统 `IO` 执行完成的话，这种 `IO` 执行策略就为 `同步`，如果进程或线程并不挂起而是继续工作，这种 `IO` 执行策略便为 `异步`。

综上：关键点是要将应用程序的 `IO` 操作分为两个步骤来理解：`IO调用` 和 `IO执行`。`IO调用` 才是应用程序干的事情，而 `IO执行` 是操作系统的工作。在 `IO调用` 时，对待操作系统 `IO` 就绪状态的不同方式，决定了其是 `阻塞或非阻塞模式` ；在 `IO执行` 时，线程或进程是否挂起等待 `IO` 执行决定了其是否为 `同步或异步IO` 。

以上摘自 [程序员应该这样理解IO](https://www.jianshu.com/p/fa7bdc4f3de7)

### 常见的 IO 模型？

`UNIX` 系统下， `IO` 模型一共有 `5` 种

- 同步阻塞 I/O
- 同步非阻塞 I/O
- I/O 多路复用
- 信号驱动 I/O
- 异步 I/O

对于如何去理解 `UNIX` 得 `I/O 模型`，大致就是从区分同步异步和区分阻塞非阻塞这两个方面理解。

### Java I/O 模型？

- **BIO (Blocking I/O)**

> BIO（blocking IO） 即阻塞 IO。指的主要是传统的 java.io 包，它基于流模型实现。

`BIO` 属于同步阻塞 `IO` 模型，会阻塞进程，不适合高并发场景。`BIO` 的优点是代码比较简单、直观；缺点则是 `IO` 效率和扩展性存在局限性，容易成为应用性能的瓶颈。

在服务器中实现的模式为 **一个连接一个线程** ，也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。`BIO` 一般适用于 **连接数目小且固定的架构**，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是 `JDK1.4` 之前的唯一选择，但好在程序直观简单，易理解。

- **NIO (Non-blocking / New I/O)**

> Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。

`java.nio` 包提供了 `Channel`、`Selector`、`Buffer` 等新的抽象，可以构建 `多路复用的`、`同步非阻塞` `IO` 程序，同时提供了更接近操作系统底层的高性能数据操作方式。

在服务器中实现的模式为 **一个请求一个线程**，即当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。`BIO` 与 `NIO` 一个比较重要的不同，当使用 `BIO` 的时候往往会引入多线程，每个连接一个单独的线程；而 `NIO` 则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。 `NIO` 一般适用于 **连接数目多且连接比较短（轻操作）的架构**，相对复杂一些，从`JDK1.4` 开始支持。

- **AIO (Asynchronous I/O)**

> AIO 也就是 NIO 2，Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。

异步 `IO` 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

服务器实现模式为一个有效请求一个线程，客户端的 `IO` 请求都是由 `OS` 先完成了再通知服务器应用去启动线程进行处理。

目前来说 `AIO` 的应用还不是很广泛。`Netty` 之前也尝试使用过 `AIO`，不过又放弃了。这是因为，`Netty` 使用了 `AIO` 之后，在 `Linux` 系统上的性能并没有多少提升。

### 字符流与字节流的区别？

**首先从不同角度看，`Java` 中 `IO` 流可以这么分：**

- 按照流的方向：`输入流（inputStream）`和 `输出流（outputStream）`；
- 按照实现功能分：`节点流`（可以从或向一个特定的地方读写数据，如 `FileReader` ）和 `处理流`（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， `BufferedReader`）；
- 按照处理数据的单位： `字节流` 和 `字符流`。分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:`InputStream`，`OutputStream`，`Reader`，`Writer`。`Java`中其他多种多样变化的流均是由它们派生出来的。

**大多情况是从按照处理数据的单位来区分。字节流 vs. 字符流区别：**

- **核心类**

字节流有两个核心抽象类：`InputStream` 和 `OutputStream`。所有的字节流类都继承自这两个抽象类。

![](https://resource.lzyan.fun/PigGo/20220220171346.png)

字符流有两个核心类：`Reader` 类和 `Writer` 。所有的字符流类都继承自这两个抽象类。

![](https://resource.lzyan.fun/PigGo/20220220171533.png)

- **相同点**

字节流和字符流都有 `read()`、`write()`、`flush()`、`close()` 这样的方法，这决定了它们的操作方式近似。

- **不同点**

    1. 数据类型
        - `字节流` 的数据是 `字节（二进制对象）`。主要核心类是 `InputStream` 类和 `OutputStream` 类。
        - `字符流` 的数据是 `字符`，一个字符等于两个字节。主要核心类是 `Reader` 类和 `Writer` 类。
    2. 缓冲区
        - `字节流` 在操作时本身不会用到`缓冲区（内存）`，是文件直接操作的。
        - `字符流` 在操作时是使用了 `缓冲区`，通过缓冲区再操作文件。

- **选择**

所有的文件在硬盘或传输时都是以字节方式保存的，例如图片，影音文件等都是按字节方式存储的。字符流是由 `Java` 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以，`I/O` 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。字符流无法读写这些文件。所以，除了纯文本数据文件使用字符流以外，其他文件类型都应该使用字节流方式。

## NIO

### NIO 和 传统 I/O 的主要区别？

- **阻塞与非阻塞IO**

`传统IO` 亦指 `BIO`，`BIO` 是阻塞的，`NIO` 是非阻塞的。 

- **BIO 面向流(Stream oriented)，NIO 面向块\缓冲区(Buffer oriented)**

`Buffer(缓冲区)` 是一个对象，它包含一些要写入或者要读出的数据。在 `NIO` 类库中加入 `Buffer` 对象，体现了 `NIO` 与 `BIO` 的一个重要区别。在面向流的 `BIO` 中可以将数据直接写入或者将数据直接读到 `Stream` 对象中。虽然 `Stream` 中也有 `Buffer` 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 `NIO` 却是直接读到 `Buffer` 中进行操作。

在 `NIO` 厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读缓冲区中的数据; 在写入数据时，写入到缓冲区中。任何时候访问 `NIO` 中的数据，都是通过缓冲区进行操作。

最常用的缓冲区是 `ByteBuffer`,一个 `ByteBuffer` 提供了一组功能用于操作 `byte` 数组。除了 `ByteBuffer`,还有其他的一些缓冲区，事实上，每一种 `Java` 基本类型（除了 `Boolean` 类型）都对应有一种缓冲区。

- **NIO 通过Channel（通道） 进行读写**

通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和 `Buffer` 交互。因为 `Buffer` 通道可以异步地读写。

通常来说 `NIO` 中的所有 `IO` 都是从` Channel（通道）` 开始的：从通道进行数据读取——创建一个缓冲区，然后请求通道读取数据；从通道进行数据写入——创建一个缓冲区，填充数据，并要求通道写入数据。

- **NIO 有Selectors(选择器)，BIO 没有**

`NIO` 的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

### NIO 的三个核心部分及作用？

`NIO` 包含下面几个核心的组件：`Channel(通道)`、`Buffer(缓冲区)`、`Selector(选择器)`

- **Channel(通道)**

`Channel(通道)` 是对传统 `I/O` 包中的流的模拟，可以通过它读取和写入数据。

通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 `InputStream` 或者 `OutputStream` 的子类)，而通道是 `双向` 的，可以用于读、写或者同时用于读写。

通道包括以下类型：
  1. `FileChannel`：从文件中读写数据；
  2. `DatagramChannel`：通过 `UDP` 读写网络中数据；
  3. `SocketChannel：`通过 `TCP` 读写网络中数据；
  4. `ServerSocketChannel`：可以监听新进来的 `TCP` 连接，对每一个新进来的连接都会创建一个 `SocketChannel`。

- **Buffer(缓冲区)**

`NIO` 与传统 `I/O` 不同，它是基于 `块（Block）`的，它以块为基本单位处理数据。`Buffer` 是一块连续的内存块，是 `NIO` 读写数据的缓冲。`Buffer` 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。

发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。

缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

`java.io.*` 已经以 `NIO` 为基础重新实现了，所以现在它可以利用 `NIO` 的一些特性。例如，`java.io.*` 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。

缓冲区包括以下类型：
  1. `ByteBuffer`
  2. `CharBuffer`
  3. `ShortBuffer`
  4. `IntBuffer`
  5. `LongBuffer`
  6. `FloatBuffer`
  7. `DoubleBuffer`

缓冲区状态变量：
  1. `capacity`：最大容量；
  2. `position`：当前已经读写的字节数；
  3. `limit`：还可以读写的字节数。
  4. `mark`：记录上一次 `postion` 的位置，默认是 `0`，算是一个便利性的考虑，往往不是必须 的

- **Selector(选择器)**

`NIO` 常常被叫做非阻塞 `IO`，主要是因为 `NIO` 在网络通信中的非阻塞特性被广泛使用。

`NIO` 实现了 `IO` 多路复用中的 `Reactor` 模型，一个线程 `Thread` 使用一个选择器 `Selector` 通过轮询的方式去监听多个通道 `Channel` 上的事件，从而让一个线程就可以处理多个事件。

通过配置监听的通道 `Channel` 为非阻塞，那么当 `Channel` 上的 `IO` 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 `Channel`，找到 `IO` 事件已经到达的 `Channel` 执行。

因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 `IO` 密集型的应用具有很好地性能。

应该注意的是，只有套接字 `Channel` 才能配置为非阻塞，而 `FileChannel` 不能，为 `FileChannel` 配置非阻塞也没有意义。

> Linux 系统提供 NIO 多路复用的三种实现机制 select、poll 和 epoll ,但目前操作系统的 I/O 多路复用机制都使用了 epoll，相比传统的 select 机制，epoll 没有最大连接句柄 1024 的限制。所以 Selector 在理论上可以轮询成千上万的客户端。
>
> select：无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作，会
维护一个文件描述符 FD 的集合 fd_set，将 fd_set 从用户空间复制到内核空间。x86
fd_set 是数组结构
>
> epoll：不再扫描所以 fd，只将用户关心的事件放在内核的一个事件表中，减少用户空间
和内核空间的数据拷贝。epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，
epoll 会把哪个流发生了怎样的 I/O 事件通知我们。

![](https://resource.lzyan.fun/PigGo/321.png)

### NIO 与 Netty 的关系？

`Netty` 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。`Netty` 本质是一个基于 `NIO` 的框架，但 `Netty` 的异步还是基于多路复用的，并没有实现真正意义上的异步 `IO`。底层是 `NIO`，`NIO` 底层是 `传统 IO` 和 `网络IO`，再往下是 `TCP/IP` 协议。它极大地简化并优化了 `TCP` 和 `UDP` 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。支持多种协议。

不直接用 `NIO` 主要是因为 `NIO` 的编程模型复杂而且存在一些 `BUG`，并且对编程功底要求比较高，比如：需要自己构建协议、解决 `TCP` 传输问题，如粘包、半包、因为 `bug` 的存在，`epoll` 空轮询导致 `CPU 100%`等问题。

`Netty` 具有这些优点，并且相比于直接使用 `JDK` 自带的 `NIO` 相关的 `API` 来说更加易用：
- 统一的 `API`，支持多种传输类型，阻塞和非阻塞的。
- 简单而强大的线程模型。
- 自带编解码器解决 `TCP` 粘包/拆包问题。
- 自带各种协议栈。
- 真正的无连接数据包套接字支持。
- 比直接使用 `Java` 核心 `API` 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。
- 安全性不错，有完整的 `SSL/TLS` 以及 `StartTLS` 支持。
- 社区活跃，成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 `Netty`， 比如 `Dubbo`、`RocketMQ`、`Elasticsearch`、`gRPC` 等等。

### NIO 中的零拷贝？

## 序列化

### 序列化与反序列化是什么？

`Java` 对象是保存在 `JVM` 的堆内存中的，也就是说，如果 `JVM` 堆不存在了，那么对象也就跟着消失了。而 `序列化` 提供了一种方案，可以让你在即使 `JVM` 停机的情况下也能把对象保存下来的方案，持久化 `Java` 对象将 `Java` 对象保存在文件中。或者在网络传输 `Java` 对象，这些场景都需要用到序列化。


- **序列化**： 将数据结构或对象转换成二进制字节流的过程。

- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。

对于 `Java` 这种面向对象编程语言来说，序列化的都是 `对象（Object）`也就是实例化后的 `类(Class)`，但是在 `C++` 这种半面向对象的语言中，`struct(结构体)` 定义的是数据结构类型，而 `class` 对应的是对象类型。

Java的序列化机制可以导致一个实例能直接从 `byte[]` 数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的 `byte[]` 数组被反序列化后可以执行特定的 `Java` 代码，从而导致严重的安全漏洞。实际上，`Java` 本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过 `JSON` 这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。

**综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中，Java 的序列化机制仅适用于 Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。**

![](https://resource.lzyan.fun/PigGo/20220221214744.png)

### 序列化的实现方式有哪些？

- **Serializable 接口**

序列化的类需要实现 `Serializable` 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。

`serialVersionUID` 是 `Java` 为每个序列化类产生的版本标识。它可以用来保证在反序列时，发送方发送的和接受方接收的是可兼容的对象。如果接收方接收的类的 `serialVersionUID` 与发送方发送的 `serialVersionUID` 不一致，会抛出 `InvalidClassException`。

如果可序列化类没有显式声明 `serialVersionUID`，则序列化运行时将基于该类的各个方面计算该类的默认 `serialVersionUID` 值。尽管这样，还是建议在每一个序列化的类中显式指定 `serialVersionUID` 的值。因为不同的 `jdk` 编译很可能会生成不同的 `serialVersionUID` 默认值，从而导致在反序列化时抛出 `InvalidClassExceptions` 异常。

《阿里巴巴开发手册》上有这样一条规定

![](https://resource.lzyan.fun/PigGo/20220222215703.png)

- **Externalizable 接口**

`JDK` 中提供了另一个序列化接口 `Externalizable`。

