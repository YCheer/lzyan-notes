## 基础

### Redis 是什么？

`Redis` 全称为：Remote Dictionary Server（远程数据服务），**Redis 就是一个使用 C 语言开发的非关系型（NoSQL）键值数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的** ，也就是说它是内存数据库，所以读写速度非常快，因此 `Redis` 被广泛应用于缓存方向。另外，`Redis` 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。`Redis` 提供了多种数据类型来支持不同的业务场景，`Redis` 还支持事务 、持久化、Lua 脚本、多种集群方案。

### Redis 的应用场景

- **缓存** - 将热点数据存放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。

- **计数器** - Redis 这种内存数据库支持计数器频繁的读写操作。

- **应用限流** - 限制一个网站的访问流量。

- **消息队列** - 使用 List 数据类型，它是双向链表。

- **查找表** - 使用 HASH 数据类型。

- **交集运算** - 使用 SET 类型，例如求两个用户的共同好友。

- **排行榜** - 使用 ZSET 数据类型。

- **分布式 session** - 多个应用服务器的 Session 都存储到 Redis 中保证 Session 的一致性。

- **分布式锁** - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。

这些场景都是基于 Redis 支持的数据类型。所以需要渗入了解它所支持的数据类型，同时在 Redis 优化中还需要对底层数据结构了解。

### Redis 和 Memcached 的区别？

分布式缓存的话，使用的比较多的主要是 `Memcached` 和 `Redis`。不过，现在基本没有看过还有项目使用 `Memcached` 来做缓存，都是直接用 `Redis`。

共同点：

1. 都是基于内存的数据库，一般都用来当做缓存使用。
2. 都有过期策略。
3. 两者的性能都非常高。

区别：

1. Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。
2. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。
3. Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。
4. Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。
5. Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。
6. Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 引入了多线程 IO ）
7. Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。
8. Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

### Redis 基础数据类型

Redis 所有的 key（键）都是字符串，在谈论基础数据结构时，讨论的存储值的数据类型，主要包括 5 种基础数据类型：`String`、`List`、`Set`、`Zset`、`Hash`。[官方介绍](https://redis.io/topics/data-types)，[官方在线练习网站](https://try.redis.io/)，[Redis 数据类型命令大全](https://redis.io/commands#)。

- **String**

介绍：

string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（simple dynamic string，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据如数字，字符串，jpg图片或者序列化的对象。并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。并且，string类型的value值最多支持的长度为512M。

常用命令:

|  命令  |                    简述                    |             使用             |
| :----: | :----------------------------------------: | :--------------------------: |
|  get   |           获取存储在给定键中的值           |           GET name           |
|  set   |           设置存储在给定键中的值           |        SET name value        |
|  del   |           删除存储在给定键中的值           |           DEL name           |
|  incr  |              将键存储的值加1               |           INCR key           |
|  decr  |              将键存储的值减1               |           DECR key           |
| incrby |            将键存储的值加上整数            |      INCRBY key amount       |
| decrby |            将键存储的值减去整数            |      DECRBY key amount       |
| exists |            判断某个key是否存在             |          exists key          |
| strlen |        返回key所存储的字符串的长度         |          strlen key          |
|  mset  |          批量设置key-value类型值           | mset key1 value1 key2 value2 |
|  mget  |         批量获取多个key对应的value         |        mget key1 key2        |
| expire |              设置数据过期时间              |        expire key 60         |
| setex  | 设置存储的键值对以及数据过期时间set+expire |      setex key 60 value      |
|  ttl   |            查看数据还有多久过期            |           ttl key            |

实战场景：

1. 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。 
2. 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。 
3. session：常见方案spring session + redis实现session共享。
4. 单点登录：把token保存到redis，并设置过期时间。

- **List**

介绍：

list 即是 链表。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

常用命令：

|  命令  |                         简述                         |      使用       |
| :----: | :--------------------------------------------------: | :-------------: |
| rpush  |                向list的最右端添加元素                | rpush key value |
| lpush  |                向list的最左端添加元素                | lpush key value |
|  rpop  |                向list的最右端取出元素                |    rpop key     |
|  lpop  |                向list的最左端取出元素                |    lpop key     |
| lrange | 获取指定范围的值，-1为倒数第一，0 -1表示获取所有元素 | lrange key 0 -1 |
| lindex |               通过索引获取list中的元素               |  lindex key -1  |
|  llen  |                    查看list的长度                    |    llen key     |

组合命令可以实现的使用技巧：

1. lpush+lpop=Stack(栈)
2. lpush+rpop=Queue（队列）
3. lpush+ltrim=Capped Collection（有限集合）
4. lpush+brpop=Message Queue（消息队列）

实战场景：

1. 微博 TimeLine : 有人发布微博，用lpush加入时间轴，展示新的列表信息。
2. 消息队列。
3. 粉丝列表、商品列表。

- **Set**

介绍：

set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。

常用命令：

|   命令    |                   简述                    |          使用          |
| :-------: | :---------------------------------------: | :--------------------: |
|   sadd    |         向set中添加一个或多个元素         | sadd key value1 value2 |
|   scard   |             获取set的元素数量             |       scard key        |
|  smember  |            获取set中的所有元素            |      smember key       |
| sismember | 检查某个元素是否存在set中，只接收单个元素 |  sismember key value   |

实战场景:

1. 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。
2. 点赞，或点踩，收藏等，可以放到set中实现。

- **Hash**

介绍：

hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。

常用命令：

|  命令   |                 简述                 |                   使用                    |
| :-----: | :----------------------------------: | :---------------------------------------: |
|  hmset  |            添加键值对数据            | hmset key field1 "value1" field2 "value2" |
| hexists | 查看key对应value中指定的字段是否存在 |            hexists key filed1             |
|  hget   |    获取存储在hash中的指定字段的值    |              hget key filed1              |
| hgetall |    获取hash中所有的字段和对应的值    |                hgetall key                |
|  hkeys  |          获取hash中字段列表          |                 hkeys key                 |
|  hvals  |         获取hash中value列表          |                havals key                 |
|  hset   |         修改某个字段对应的值         |          hset key filed1 "value"          |

- **Zset**

介绍：

也称为 sorted set ， 和 set， 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。

常用命令：

|   命令    |                简述                |        使用        |
| :-------: | :--------------------------------: | :----------------: |
|   zadd    | 将元素添加到zset中，并且分配权重值 | zadd key 3.0 value |
|   zcard   |        查看zset中元素的数量        |     zcard key      |
|  zscore   |        查看某个value的权重         |  zscore key value  |
|  zrange   |      顺序输出某个范围内的元素      |  zrange key 0 -1   |
| zrevrange |      逆序输出某个范围内的元素      | zrevrange key 0 -1 |
|   zrem    |        移除zset中的某个元素        |   zrem key value   |


实战场景：

1. 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。

实战应用方案参考：[『玩转Redis面试篇』看完这20道Redis面试题，阿里面试可以约起来了](https://github.com/CoderLeixiaoshuai/java-eight-part/blob/master/docs/redis/%E7%9C%8B%E5%AE%8C%E8%BF%9920%E9%81%93Redis%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E5%8F%AF%E4%BB%A5%E7%BA%A6%E8%B5%B7%E6%9D%A5%E4%BA%86.md#4%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8Bredis%E6%AF%8F%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%90%97)

### Redis 高级数据类型

- **BitMap**

bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。

解决的一些问题：统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ 两个状态的，都可以使用 Bitmaps。如果存储一年的打卡状态需要多少内存呢？ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！

- **HyperLogLog**

HyperLogLog 是用于计算唯一事物的概率数据结构（从技术上讲，这被称为估计集合的基数）。如果统计唯一项，项目越多，需要的内存就越多。因为需要记住过去已经看过的项，从而避免多次统计这些项。

什么是基数，举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9；（允许容错，即可以接受一定误差）。

解决的一些问题：这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。

优势的体现：一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。

- GEO

这个功能可以将用户给定的地理位置（经度和纬度）信息储存起来，并对这些信息进行操作。


### 可以做消息队列的数据类型 Stream

`Redis 5.0` 新增加的一个数据结构 `Stream` ，它借鉴了 `Kafka` 的设计，是一个新的强大的支持多播的可持久化的消息队列。 相关文章: [Redis 消息队列的三种方案（List、Streams、Pub/Sub）](https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)

## 持久化和内存

### Redis 为什么需要持久化

`Redis` 的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证 `Redis` 的数据不会因为故障而丢失，这种机制就是 `Redis` 的持久化机制，它会将内存中的数据库状态 保存到磁盘中。

`Redis` 有两种持久化的方式：**快照（RDB文件）**和 **追加式文件（AOF文件)**

选择之前需要搞清楚每种持久化方式的区别以及各自的优劣势。

### RDB 持久化

- **简介**

`RDB(Redis Database)` 持久化是把当前内存数据生成快照保存到硬盘的过程，它将某个时间点的所有 `Redis` 数据保存到一个经过压缩的二进制文件（RDB 文件）中。创建 RDB 后，用户可以对 RDB 进行备份，可以将 RDB 复制到其他服务器从而创建具有相同数据的服务器副本，还可以在重启服务器时使用。一句话来说：RDB 适合作为 冷备。快照持久化是 Redis 默认采用的持久化方式。

- **优点**

1. RDB 文件非常紧凑，适合作为冷备。比如你可以在每个小时报保存一下过去 24 小时内的数据，同时每天保存过去 30 天的数据，这样即使出了问题你也可以根据需求恢复到不同版本的数据集。

2. 快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 Redis 的性能。

3. 恢复大数据集时，RDB 比 AOF 更快。

- **缺点**

1. 如果系统发生故障，将会丢失最后一次创建快照之后的数据。如果你希望在 Redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么 快照不适合你。虽然你可以配置不同的 save 时间点(例如每隔 5 分钟并且对数据集有 100 个写的操作)，是 Redis 要完整的保存整个数据集是一个比较繁重的工作，你通常会每隔 5 分钟或者更久做一次完整的保存，万一在 Redis 意外宕机，你可能会丢失几分钟的数据。

2. 如果数据量很大，保存快照的时间会很长。快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且 CPU 性能不是很好的情况下，这种情况会持续 1 秒。AOF 也需要 fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度。

- **创建**

触发 `RDB` 持久化过程分为手动触发和自动触发。

手动触发：手动触发对应 save 命令，会阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。

自动触发：自动触发对应 bgsave 命令，Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。

> 不是说 Redis 是单线程吗？
>
> Redis 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化（在执行快照的同时，正常处理写操作）， fork 是类 Unix 操作系统上创建进程的主要方法。COW(Copy On Write)是计算机编程中使用的一种优化策略。
>
> fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。 子进程读取数据，然后序列化写到磁盘中。
>
> Redis在较新的版本中，有些地方都使用了多线程来进行处理比如说，一些删除的操作（UNLINK、FLUSHALL ASYNC等等）还有Redis 6.x 之后对网络数据的解析都用了多线程处理了。
>
> 只不过，核心的处理命令请求和响应还是单线程。

### AOF 持久化

- 简介

`AOF(Append Only File)` 是以 文本日志形式 将 所有写命令以 Redis 命令请求协议格式追加到 AOF 文件的末尾，以此来记录数据的变化。当服务器重启时，会重新载入和执行 AOF 文件中的命令，就可以恢复原始的数据。AOF 适合作为 热备。AOF 的主要作用是解决了数据持久化的实时性，目前已经是 Redis 持久化的主流方式。

- **优点**

1. 如果系统发生故障，AOF 丢失数据比 RDB 少。你可以使用不同的 fsync 策略：无 fsync；每秒 fsync；每次写的时候 fsync。使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，你最多丢失 1 秒的数据。

2. AOF 文件可修复 - AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。

3. AOF 文件可压缩。Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

4. AOF 文件可读 - AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 命令的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单。举个例子，如果你不小心执行了 FLUSHALL 命令，但只要 AOF 文件未被重写，那么只要停止服务器，移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis ，就可以将数据集恢复到 FLUSHALL 执行之前的状态。

- **缺点**

1. AOF 文件体积一般比 RDB 大，对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。

2. 恢复大数据集时，AOF 比 RDB 慢。根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。

- **创建**

默认情况下 `Redis` 没有开启 `AOF（append only file）`方式的持久化，可以通过 `appendonly` 参数开启。

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 `server.aof_buf `中，然后再根据 `appendfsync` 配置来决定何时将其同步到硬盘中的 AOF 文件。

AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 `dir` 参数设置的，默认的文件名是 `appendonly.aof`。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

```
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

为了兼顾数据和写入性能，用户可以考虑 `appendfsync everysec` 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

- 重写问题

AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。

在执行 `BGREWRITEAOF` 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。

### 如何选择持久化

> Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。
>
> 如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

1. 如果不关心数据丢失，可以不持久化。
2. 如果可以承受数分钟以内的数据丢失，可以只使用 RDB。
3. 如果不能承受数分钟以内的数据丢失，可以使用 AOF，或者建议同时使用 RDB 和 AOF。

再具体的如何选择要据真实场景而论。

### Redis 内存淘汰机制

**先从给数据设置过期时间谈起：**

一般情况下，设置保存的缓存数据的时候都会设置一个过期时间，因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 `Out of memory`。

过期时间除了有助于缓解内存的消耗，很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。

**到 Redis 如何判断数据是否过期：**

Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。每当我们设置一个键的过期时间时，Redis 就会将该键带上过期时间存放到一个过期字典中。当我们查询一个键时，Redis 便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。

**再到过期的数据的删除策略：**

什么是过期数据的删除策略：假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除。

常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：

1. 惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
2. 定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响

定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 `定期删除+惰性/懒汉式删除 `。

但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就` Out of memory` 了。那么就应该采用 `Redis 内存淘汰机制`了。

**最后引入 Redis 的内存淘汰机制：**

Redis 提供 8 种数据淘汰策略：

1. `volatile-lru（least recently used）`：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. `volatile-ttl`：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. `volatile-random`：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. `allkeys-lru（least recently used）`：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. `allkeys-random`：从数据集（server.db[i].dict）中任意选择数据淘汰
6. `no-eviction`：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

1. `volatile-lfu（least frequently used）`：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰
2. `allkeys-lfu（least frequently used）`：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

## 事务

### Redis 事务生命周期

Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。Redis事务执行是三个阶段：

* 开启事务：使用MULTI开启一个事务
* 命令入队列：每次操作的命令都会加入到一个队列中，但命令此时不会真正被执行
* 提交事务：使用EXEC命令提交事务，开始顺序执行队列中的命令

可以将 Redis 中的事务就理解为 ：**Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。**

### Redis 事务相关命令

- **WATCH**

可以为Redis事务提供 check-and-set （CAS）行为。被WATCH的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。

- **MULTI**

用于开启一个事务，它总是返回OK。MULTI执行之后,客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行，而是被放到一个队列中，当 EXEC命令被调用时， 所有队列中的命令才会被执行。

- **UNWATCH**

取消 WATCH 命令对所有 key 的监视，一般用于DISCARD和EXEC命令之前。如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。

- **DISCARD**

当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空，并且客户端会从事务状态中退出。

- **EXEC**

负责触发并执行事务中的所有命令。

如果客户端成功开启事务后执行EXEC，那么事务中的所有命令都会被执行。

如果客户端在使用MULTI开启了事务后，却因为断线而没有成功执行EXEC,那么事务中的所有命令都不会被执行。需要特别注意的是：即使事务中有某条/某些命令执行失败了，事务队列中的其他命令仍然会继续执行，Redis不会停止执行事务中的命令，而不会像我们通常使用的关系型数据库一样进行回滚。

### Redis 为什么不支持回滚？

在事务运行期间，虽然 Redis 命令可能会执行失败，但是 Redis 依然会执行事务内剩余的命令而不会执行回滚操作。熟悉 mysql 关系型数据库事务的你，可能会对这感到非常疑惑。以下是官方的理由：

- 只有当被调用的 Redis 命令有语法错误时，这条命令才会执行失败（在将这个命令放入事务队列期间，Redis能够发现此类问题），或者对某个键执行不符合其数据类型的操作：实际上，这就意味着只有程序错误才会导致 Redis 命令执行失败，这种错误很有可能在程序开发期间发现，一般很少在生产环境发现。

- 支持事务回滚能力会导致设计复杂，这与Redis的初衷相违背，Redis的设计目标是功能简化及确保更快的运行速度。

对于官方的这种理由有一个普遍的反对观点：程序有bug怎么办？但其实回归不能解决程序的bug，比如某位粗心的程序员计划更新键A，实际上最后更新了键B，回滚机制是没法解决这种人为错误的。正因为这种人为的错误不太可能进入生产系统，所以官方在设计Redis时选用更加简单和快速的方法，没有实现回滚的机制。

### Redis 事务到底是不是原子性的？

先看关系型数据库ACID 中关于原子性的定义：

**原子性：**一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。

官方文档对事务的定义：

* **事务是一个单独的隔离操作**：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
* **事务是一个原子操作**：事务中的命令要么全部被执行，要么全部都不执行。EXEC 命令负责触发并执行事务中的所有命令：如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。

官方认为Redis事务是一个原子操作，这是站在执行与否的角度考虑的。但是从ACID原子性定义来看，**严格意义上讲Redis事务是非原子型的**，因为在命令顺序执行过程中，一旦发生命令执行错误Redis是不会停止执行然后回滚数据。

## 经典问题

### 缓存雪崩

缓存雪崩，指的是缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量的请求而崩掉。

解决方案：

- **Redis 高可用**，主从+哨兵，Redis cluster，避免全盘崩溃。

- 本地 ehcache 缓存 + hystrix **限流&降级**，避免 MySQL 被打死。

- **缓存数据的过期时间设置随机**，防止同一时间大量数据过期现象发生。

- 逻辑上永不过期给每一个缓存数据增加相应的 **缓存标记**，缓存标记失效则更新数据缓存。

- **多级缓存**，失效时通过二级更新一级，由第三方插件更新二级缓存。

### 缓存穿透

缓存是为了缓解数据库压力而添加的一层保护层，当从缓存中查询不到我们需要的数据就要去数据库中查询了。如果被黑客利用，频繁去访问缓存中没有的数据，那么缓存就失去了存在的意义，瞬间所有请求的压力都落在了数据库上，这样会导致数据库连接异常。

解决方案：

- 最基本的办法，**接口层增加校验**，如用户鉴权校验，id 做基础校验，id<=0 的直接拦截

- ​从缓存取不到的数据，在数据库中也没有取到，这时也可以将 **key-value 对写为 key-null** ，缓存有效时间可以设置短点，如30秒。这样可以防止攻击用户反复用同一个 id 暴力攻击；（这种方式很容易破解）

- 采用 **布隆过滤器** ，将所有可能存在的数据值存放到一个足够大的 **布隆过滤器** 中，当用户请求过来，先判断用户发来的请求的值是否存在于 **布隆过滤器** 中，**一个一定不存在的数据会被这个布隆过滤器拦截掉**（ 需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： 布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。为什么会出现误判的情况呢，还要从 布隆过滤器 的原理来说），从而避免了对底层存储系统的查询压力。（宁可错杀一千不可放过一人，比较稳的一种方式）

### 缓存击穿

在高并发下，并发用户特别多，对一个特定的值进行查询，但是这个时候缓存正好过期了，查询缓存不能命中，导致大量的请求都直接落到了数据库上，造成瞬时数据库请求量大，甚至可能打垮数据库。说白了，就是某个数据，数据库有，但是缓存中没有。

解决方案：

- **热点数据不过期**，直接将缓存设置不过期，然后由定时任务去异步加载数据，更新缓存。

- **加互斥锁**，在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。

- **缓存预热**，系统上线后，将相关可预期（例如排行榜）热点数据直接加载到缓存。

### 缓存和数据库的一致性

[如何保证缓存和数据库的一致性？](https://mp.weixin.qq.com/s/7-vUDQGj8mZIeryZA3gEiw)

[缓存和数据库一致性问题，看这篇就够了](https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd)

## 参考

- [Redis知识点&面试题总结](https://javaguide.cn/database/redis/redis-questions-01/#)

- [Redis 教程](https://dunwu.github.io/db-tutorial/nosql/redis/#)

- [Redis 知识体系详解](https://www.pdai.tech/md/db/nosql-redis/db-redis-overview.html)

- [JavaKeeper Redis](https://javakeeper.starfish.ink/data-management/Redis/ReadRedis.html#redis-%E7%AE%80%E4%BB%8B)

- [Redis 事务](https://github.dev/CoderLeixiaoshuai/java-eight-part/blob/master/docs/redis/%E9%9D%A2%E8%AF%95%E5%AE%98%E5%86%8D%E9%97%AERedis%E4%BA%8B%E5%8A%A1%E6%8A%8A%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E6%89%94%E7%BB%99%E4%BB%96.md)