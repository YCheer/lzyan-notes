## 过滤器 Filter

- **概念：**

对目标资源的请求和响应进行截取。`Filter` 过滤器主要是用来过滤用户请求的，它允许我们对用户请求进行前置处理和后置处理，比如实现 `URL` 级别的权限控制、过滤非法请求等

或者说在请求到达servlet之前，进行逻辑判断，判断是否放行到 `servlet` ；也可以在一个响应 `response` 到达客户端之前进行过滤，判断是否允许返回客户端

`Filter` 过滤器是面向切面编程——AOP 的具体实现

`Filter` 是依赖于 `Servlet` 容器，`Filter` 接口就在 `Servlet` 包下面，属于 `Servlet` 规范的一部分

- **一些应用的场景：**

用户授权的过滤器：判断用户是否有权限请求界面

日志信息的过滤器：过滤用户在网站的所有请求，记录轨迹

负责解码的过滤器：规定请求的解码方式

## 拦截器 interceptor

- **概念：**

Java 中的拦截器是动态拦截 `action` 调用的对象。依赖于 web 框架，在 SpringMVC 中依赖于 SpringMVC 框架，在实现上基于 Java 的反射机制，属于 AOP 的一种应用，作用类似于过滤器，但是拦截器只能对 `Controller` 请求进行拦截，对其他的直接访问静态资源的请求无法拦截处理。

使用时实现 `HandlerInterceptor` 接口

## 区别

1. 使用的范围不同

   - `filter` 是 `servlet` 规范规定的,只能用在 web 程序中
   - 拦截器即可以用在 web 程序中, 也可以用于 application, swing 程序中, 是 Spring 容器内的, 是 Spring 框架支持的

2. 触发的时机不同

    顺序：`Filter-->Servlet-->Interceptor-->Controller`
    - 过滤器是在请求进入容器（Tomcat）后，但请求进入 servlet 之前进行预处理。请求结束返回时，是在 servlet 处理完后，返回给前端之前过滤器处理
    - 拦截器是方法到达 `Controller` 层之前生效

3. 过滤器的实现基于 `回调函数`，而拦截器（代理模式）的实现基于 `反射`

    其中代理分静态代理和动态代理，动态代理是拦截器的简单实现

    **什么时候使用拦截器或者过滤器：**

    - 如果是非 spring 项目，那么拦截器不能用，只能使用过滤器。

    - 如果是处理 controller 前后，既可以使用拦截器也可以使用过滤器。

    - 如果是处理 dispaterServlet 前后，只能使用过滤器

4. 在 action 的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次
5. 拦截器可以访问 action 上下文、值栈里的对象，而过滤器不能访问
6. 过滤器可以拦截几乎所有的请求(包含对静态资源的请求)，而拦截器只拦截 action 请求(不拦截静态资源请求)
7. 拦截器可以获取 IOC 容器中的各个 bean，而过滤器就不行，在拦截器里注入一个 service，可以调用业务逻辑
8. 拦截器是被包裹在过滤器之中